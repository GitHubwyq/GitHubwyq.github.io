<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue知识点汇总]]></title>
    <url>%2F2019%2F05%2F23%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试版权]]></title>
    <url>%2F2019%2F05%2F18%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记一次笔试面试题经历刚拿到题目的时候是有点懵逼的。问了一下面试官，确定了一下需求。开始着手 附上笔试题链接（http://face.gokxd.cn/） 题目大体需求：两张照片合成一张，只替换照片的人脸部分明确步骤: ①、给出的页面有点不简洁明了，自己动手重新设计布局②、确定开放api接口（推荐使用face++，传送门）③、上传照片时需要判断是否是人物照片（调用接口地址，传送门） 附上部分代码部分识别人脸部分代码1234567891011121314151617181920212223$.ajax(&#123; url: url, type: 'POST', data: data, cache: false, success(data) &#123; console.log(data.faces.length) //data.faces 被检测出的人脸数组，具体包含内容见下文。注：如果没有检测出人脸则为空数组 if(data.faces.length != 0)&#123; document.getElementById('show').src=base1; &#125;else if(data.faces.length == 0)&#123; $.alert(&#123; title: '', text: '未检测到人脸,请重新选择图片！', onOK: function () &#123; //点击确认 &#125; &#125;); &#125; &#125;, &#125;) 人脸融合部分代码123456789101112131415161718192021222324252627var postData = &#123; api_key:'你注册的api_key', api_secret:'你注册的api_secret', template_base64:mouldPhoSrc, // template_rectangle:'70,80,100,100', merge_base64:fusePhoSrc&#125;$.ajax(&#123; dataType: 'json', type: 'POST' , url: 'https://api-cn.faceplusplus.com/imagepp/v1/mergeface', data: postData, success: function(response)&#123; if(typeof(response.error_message) == "undefined")&#123; // todo: 在这里添加生成后的逻辑，response.result 为生成图的base64编码 $('.uploadpic').attr('src', 'data:image/jpg/png;base64,' + response.result); &#125;else&#123; // todo: 在这里添加上传失败的逻辑 alert('请重新上传照片23'); &#125; &#125;, error: function(xhr, status, error)&#123; console.log(xhr.responseText); // todo: 在这里添加上传失败的逻辑 alert('请重新上传照片'); &#125;&#125;); 附上完整项目链接，由于没做屏幕适配，所以移动端画面有点乱，后续进行优化。 人脸融合传送门]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序和vue有哪些不同？]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Cvue%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1.生命周期小程序 onLoad：页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow：页面显示 每次打开页面都会调用一次 onReady：页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。12345wx.setNavigationBarTitle(&#123;title:this.data.titleName&#125;); onHide：页面隐藏 当 navigateTo或底部tab切换时调用。 onUnload：页面卸载 当 redirectTo或 navigateBack的时候调用。 Vue.js 创建前/后：(这两个生命周期里获取不到dom元素) 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后：（mounted生命周期里可以获取到dom元素） 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后： 当data变化时，会触发beforeUpdate和updated方法。 销毁前/后： 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 2、数据双向绑定1、设置值 在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。12345678910&lt;div id="app"&gt; &lt;input v-model="reason" placeholder="填写理由" class='reason'/&gt;&lt;/div&gt; new Vue(&#123; el: '#app', data: &#123; reason:'' &#125;&#125;) 然而在小程序中，却没有这个功能。 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。 下面是代码123456789101112&lt;input bindinput="bindReason" placeholder="填写理由" class='reason' value='&#123;&#123;reason&#125;&#125;' name="reason" /&gt; Page(&#123; data:&#123; reason:'' &#125;, bindReason(e) &#123; this.setData(&#123; reason: e.detail.value &#125;) &#125;&#125;) 2、取值 vue中，通过 this.reason取值。 小程序中，通过 this.data.reason取值。 3.组件通信1、子组件的使用 在vue中，需要： 1、编写子组件2、在需要使用的父组件中通过 import引入3、在 vue的 components中注册4、在模板中使用123456789101112131415161718192021222324252627282930313233343536373839404142434445//子组件 bar.vue&lt;template&gt; &lt;div class="search-box"&gt; &lt;div @click="say" :title="title" class="icon-dismiss"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:&#123; title:&#123; type:String, default:'' &#125; &#125; &#125;, methods:&#123; say()&#123; console.log('明天不上班'); this.$emit('helloWorld') &#125; &#125; &lt;/script&gt; // 父组件 foo.vue&lt;template&gt; &lt;div class="container"&gt; &lt;bar :title="title" @helloWorld="helloWorld"&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import Bar from './bar.vue'export default&#123;data:&#123; title:"我是标题"&#125;,methods:&#123; helloWorld()&#123; console.log('我接收到子组件传递的事件了') &#125;&#125;,components:&#123; Bar&#125;&lt;/script&gt; 子组件和父组件通信可以通过 this.$emit将方法和数据传递给父组件。 小程序中 1、编写子组件2、在子组件的 json文件中，将该文件声明为组件123&#123; "component": true&#125; 3、在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径123"usingComponents": &#123; "tab-bar": "../../components/tabBar/tabBar" &#125; 4、在父组件中，直接引入即可1&lt;tab-bar currentpage="index"&gt;&lt;/tab-bar&gt; 完整代码如下123456789101112// 子组件&lt;!--components/tabBar/tabBar.wxml--&gt;&lt;view class='tabbar-wrapper'&gt; &lt;view class='left-bar &#123;&#123;currentpage==="index"?"active":""&#125;&#125;' bindtap='jumpToIndex'&gt; &lt;text class='iconfont icon-shouye'&gt;&lt;/text&gt; &lt;view&gt;首页&lt;/view&gt; &lt;/view&gt; &lt;view class='right-bar &#123;&#123;currentpage==="setting"?"active":""&#125;&#125;' bindtap='jumpToSetting'&gt; &lt;text class='iconfont icon-shezhi'&gt;&lt;/text&gt; &lt;view&gt;设置&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 4、父子组件通信 在vue中父组件向子组件传递数据，只需要在子组件通过 v-bind传入一个值，在子组件中，通过 props接收，即可完成数据的传递，示例：123456789101112131415161718192021222324252627282930313233// 父组件 foo.vue&lt;template&gt; &lt;div class="container"&gt; &lt;bar :title="title"&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from './bar.vue'export default&#123;data:&#123; title:"我是标题"&#125;,components:&#123; Bar&#125;&lt;/script&gt; // 子组件bar.vue&lt;template&gt; &lt;div class="search-box"&gt; &lt;div :title="title" &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:'' &#125; &#125;&#125;&lt;/script&gt; 小程序中 父组件向子组件通信和vue类似，但是小程序没有通过 v-bind，而是直接将值赋值给一个变量，如下：1&lt;tab-bar currentpage="index"&gt;&lt;/tab-bar&gt; 此处， “index”就是要向子组件传递的值,在子组件 properties中，接收传递的值。12345678properties: &#123; // 弹窗标题 currentpage: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: 'index' // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125;&#125; 子组件向父组件通信和 vue也很类似，代码如下：1234567891011121314151617//子组件中methods: &#123; // 传递给父组件 cancelBut: function (e) &#123; var that = this; var myEventDetail = &#123; pickerShow: false, type: 'cancel' &#125; // detail对象，提供给事件监听函数 this.triggerEvent('myevent', myEventDetail) //myevent自定义名称事件，父组件中使用 &#125;,&#125; //父组件中&lt;bar bind:myevent="toggleToast"&gt;&lt;/bar&gt; // 获取子组件信息toggleToast(e)&#123; console.log(e.detail)&#125; 如果父组件想要调用子组件的方法vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：12345//子组件&lt;bar ref="bar"&gt;&lt;/bar&gt; //父组件this.$refs.bar.子组件的方法 小程序是给子组件添加 id或者 class，然后通过 this.selectComponent找到子组件，然后再调用子组件的方法,示例：12345//子组件&lt;bar id="bar"&gt;&lt;/bar&gt; // 父组件this.selectComponent('#bar').子组件的方法 5、条件渲染 vue:使用v-if指令，v-else表示v-if的else块，v-else-if表示v-if 的“else-if 块”123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 微信小程序：使用wx:if,wx:else表示wx:if的else块，wx:elif表示wx:if的”else-if”块123&lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; 1 &lt;/view&gt;&lt;view wx:elif="&#123;&#123;length &gt; 2&#125;&#125;"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 6、显示隐藏元素 VUE1v-show="..." 微信小程序：1hidden="&#123;&#123;...&#125;&#125;" 7、绑定classVue 全用v-bind，或者简写为:bind,和本有的class分开写1&lt;div class="test" v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 小程序1&lt;view class="test &#123;&#123;isActive ? 'active':'' &#125;&#125;"&gt;&lt;/view&gt; 8、事件处理Vue 使用v-on:event绑定事件，或者使用@event绑定事件(v-on可以简写为@)123456&lt;button v-on:click="counter += 1"&gt; Add 1&lt;/button&gt;&lt;button v-on:click.stop="counter+=1"&gt; Add1&lt;/button&gt; //阻止事件冒泡 微信小程序 全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件123456&lt;button bindtap="clickMe"&gt; 点击我&lt;/button&gt;&lt;button catchtap="clickMe"&gt; 点击我&lt;/button&gt; //阻止事件冒泡 9、绑定事件传参Vue vue绑定事件的函数传参数时，可以把参数写在函数后面的括号里1&lt;div @click="changeTab(1)"&gt;哈哈&lt;/div&gt; 微信小程序 微信小程序的事件我试过只能传函数名，至于函数值，可以绑定到元素中，在函数中获取1&lt;view data-tab="1" catchtap="changeTab"&gt;哈哈&lt;/view&gt; 123changeTab(e)&#123; var _tab = e.currentTarget.dataset.tab; &#125; 暂时总结这么多]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动吸顶效果的实现方式]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[实现方式1.使用 position:sticky 实现 2.使用 JQuery 的 offset().top 实现 3.使用原生的 offsetTop 实现 一、使用 position:sticky 实现 1.什么是sticky（粘性定位） 粘性定位 sticky 相当于相对定位 relative 和固定定位 fixed 的结合；在页面元素滚动过程中，某个元素距离其父元素的距离达到 sticky 粘性定位的要求时；元素的相对定位 relative 效果变成固定定位 fixed 的效果。 2.如何使用？ 使用条件 1.父元素不能 overflow:hidden 或者 overflow:auto 属性;2.必须指定 top、bottom、left、right 4 个值之一，否则只会处于相对定位3.父元素的高度不能低于 sticky 元素的高度4.sticky 元素仅在其父元素内生效 在需要滚动吸顶的元素加上以下样式便可以实现这个效果：12345.sticky &#123; position: -webkit-sticky; position: sticky; top: 0;&#125; 二、使用 JQuery 的 offset().top 实现我们知道 JQuery 中封装了操作 DOM 和读取 DOM 计算属性的 API，基于 offset().top 这个 API 和 scrollTop() 的结合，我们也可以实现滚动吸顶效果。 12345678 window.addEventListener('scroll', self.handleScrollOne);...handleScrollOne: function() &#123; let self = this; let scrollTop = $('html').scrollTop(); let offsetTop = $('.title_box').offset().top; self.titleFixed = scrollTop &gt; offsetTop;&#125; 三、使用原生的 offsetTop 实现我们知道 offsetTop 是相对定位父级的偏移量，倘若需要滚动吸顶的元素出现定位父级元素，那么 offsetTop 获取的就不是元素距离页面顶部的距离。我们可以自己对 offsetTop 做以下处理： 12345678910111213141516171819202122232425 getOffset: function(obj,direction)&#123; let offsetL = 0; let offsetT = 0; while( obj!== window.document.body &amp;&amp; obj !== null )&#123; offsetL += obj.offsetLeft; offsetT += obj.offsetTop; obj = obj.offsetParent; &#125; if(direction === 'left')&#123; return offsetL; &#125;else &#123; return offsetT; &#125;&#125; ``` ##### 使用 ```jswindow.addEventListener('scroll', self.handleScrollTwo);...handleScrollTwo: function() &#123; let self = this; let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; let offsetTop = self.getOffset(self.$refs.pride_tab_fixed); self.titleFixed = scrollTop &gt; offsetTop;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[琐碎小问题！]]></title>
    <url>%2F2018%2F02%2F04%2F%E7%90%90%E7%A2%8E%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、去除select的默认三角样式12345select&#123; -webkit-appearance: none; -webkit-tap-highlight-color: #fff; outline: 0;&#125; 2、文字超出隐藏12345div&#123; overflow: hidden; white-space: nowrap; //不换行 text-overflow: ellipsis; //超出省略号&#125; 3、iframe通过下列代码可以实现去除边框，滚动条，但是需要调整好高度，而且对应的子页面，高度应该是固定的，才容易使用 1&lt;iframe src="http://www.zhixin001.com/test/about.html" style="width:100%;height:1100px" name="iframe_a" frameborder="no" border="0" marginwidth="0" marginheight="0" scrolling="no" allowtransparency="yes"&gt;&lt;/iframe&gt; 4、如何控制窗体滚动高度的问题？如果只是为了获取当前网页的窗体的滚动高度，直接使用window.pageYOFFset就可以了（IE9+），桌面和移动端都支持但是window.pageYOFFset是一个只读属性，我们无法用来设置窗体的滚动高度，此时，就要找到对应的滚动元素，通过设置scrollTop值来改变窗体的滚动位置然而，桌面和移动端的窗体滚动元素是不一样的12document.documentElement.scrollTop;（只在PC端生效）document.body.scrollTop;（只在移动端生效） 使用document.scrollingElement.scrollTop来控制如：1document.scrollingElement.scrollTop = 400 5、超出部分隐藏123overflow:hidden;text-overflow:ellipsis;white-space:nowrap 6、查看本机ip地址 命令行输入 ipconfig 7、input框只能输入整数12onkeyup="value=value.replace(/[^0-9]/g,'')" (包括0)onkeyup="value=value.replace(/^(0+)|[^\d]+/g,'')" （不包括0） 8、input框限制输入长度 （可以在type为number时 maxlength无效时使用）1oninput="if(value.length&gt;5)value=value.slice(0,5)" 9、H5和原生交互12345678910111213141516171819202122var u = navigator.userAgent, app = navigator.appVersion;var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; //gvar isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端function showToast(data)&#123; if(getCookie("VERSION")||getCookie("PHONETYPE")||getCookie("DEVICEID"))&#123; if(isIOS) &#123; window.webkit.messageHandlers.showToast.postMessage(data); &#125; else if(isAndroid) &#123; window.android.showToast(JSON.stringify(data)); &#125; &#125;else&#123; if(data.type==1)&#123; $.showLoading(" "); &#125;else if(data.type==2)&#123; $.hideLoading(); &#125;else if(data.type==3)&#123; $.toast(data.title, "text"); &#125; &#125;&#125; 10、修改单选框和复选框的样式123&lt;!-- html --&gt;&lt;input type="checkbox" id="check" name="check" /&gt;&lt;label for="check"&gt;Checkbox&lt;/label&gt; 12345678910111213141516input[type=checkbox] &#123;display: none;&#125;input[type=checkbox] + label:before &#123; content: ""; border: 1px solid #000; font-size: 11px; line-height: 10px; margin: 0 5px 0 0; height: 10px; width: 10px; text-align: center; vertical-align: middle;&#125;input[type=checkbox]:checked + label:before &#123; content: "\2713";&#125; 11、动画卡顿时，开启硬件加速123选择器&#123; transform: translateZ(0);&#125; 12、Color + Border = Border-Color1234input[type="text"] &#123; color: red; border: 1px solid;&#125; 13、高德的事件绑定123$(document).on('click','类名',function()&#123;&#125;) 14、禁止移动端背景层滚动 弹出时设置12document.body.style.overflow = 'hidden';document.documentElement.style.overflow = 'hidden' 关闭弹出层时设置 把值设置成auto即可 15、ios的回弹效果123$('').on('touchmove',function()&#123; event.preventDefault();&#125;) 16、box-shadow1box-shadow: 10px 10px 5px #88888 第一个值：水平阴影的偏移量，为正值时生成右边阴影，为负时，生成左边阴影第二个值：垂直阴影的偏移量，为正值时生成底部阴影，为负值时，生成顶部阴影第三个值：阴影模糊值第四个值：阴影颜色]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三角形原理！]]></title>
    <url>%2F2017%2F12%2F10%2Fcss%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E5%8E%9F%E7%90%86-1%2F</url>
    <content type="text"><![CDATA[对于一个块级元素，但我们分别将元素的上下左右四个border设置成一个比较大的像素（如10px），样式设置成solid ,分别设置成不同的颜色的时候，同时将元素的width,height设置为0.这时我们将会看到四条边均呈现为三角形的形状。如图： 其css样式为： 12345678.element&#123; width: 0px; height: 0px; border-top: 20px solid aqua; border-right: 20px solid #760000; border-bottom: 20px solid blue; border-left: 20px solid darkkhaki;&#125; 一个普通的div。四个三角形分别是四条border四条border所呈现出来的，而我们最终的效果好像跟一个三角形的关系比较大些。如果得到一个三角形呢？其实这个很简单，我们只需要把其余三条border颜色属性设置为transparent（透明）的样式，另一个border的颜色属性保持不变。 看代码 html部分123&lt;div class="element"&gt; &lt;/div&gt; css部分12345678.element&#123; width: 0px; height: 0px; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid darkkhaki;&#125; 此时的效果：如下图 好了，三角形出来了。那我们也就实现了最为关键的的地方。我们在弄出来一个白色的三角形，然后将白色三角形覆盖到这个有色三角形之上，但是不能完全覆盖，让其露出一个尖角的效果来。这就是基本的原理。 2.实现首先需要一个div容器，设置border,width,height的属性，同时将设置其为相对定位。 上代码 html部分123&lt;div class="angle-wrapper"&gt; &lt;/div&gt; css部分1234567.angle-wrapper &#123; width: 300px; height: 200px; position: relative; margin: 20px auto; border: 2px solid #cccccc;&#125; 效果图如下： 然后需要为这个在这个div右边框上添加两个三角形，一个三角形颜色与边框颜色相同，另一个三角形颜为白色，用于覆盖第一个三角形颜色的一部分。 这里我们使用元素的伪选择器:before,:after来加入这两个三角形，before和after默认为行内元素，所以首先要将其设置为块级元素，绝对定位。 首先添加before伪选择器，用它来生成与border颜色的相同的第一个三角形，并将其定位到左边框上。 上代码1234567891011.angle-wrapper:before &#123; content: ''; width: 0; height: 0; border: 20px solid transparent; border-left-color: #cccccc; position: absolute; left: 100%; top: 50%; margin-top: -20px;&#125; 效果图如下： 然后添加after伪选择器，用它生成一个白色的三角形，并将其定位到左边框上。这里需要注意的是白色三角形的大小要比有色三角形要小一些，小多少要根据div边框的大小而定。我这里边框为2px,所以白色三角形就比灰色三角形就小两个px。这样可以避免白色三角形将灰色三角形全覆盖，然后可以产生尖角的效果来。（我这里说的大小就是设置三角形时的border的px值，如after这里是18px,before那里是20px） 上代码：1234567891011.angle-wrapper:after &#123; content: ""; width: 0; height: 0; border: 18px solid transparent; border-left-color: #FFFFFF; position: absolute; left: 100%; top: 50%; margin-top: -18px;&#125; 效果图如下： 完成。（这个对话框做的有点丑哈）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS reset文件]]></title>
    <url>%2F2017%2F11%2F30%2Fcss-reset%2F</url>
    <content type="text"><![CDATA[css reset文件 为了复用一些css属性，最近花了点时间把一些常用的总结一下不多说，上代码 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131*&#123; margin: 0; padding: 0;&#125;html&#123; overflow-y: scroll; &#125;a&#123; text-decoration: none;&#125;a:active,a:hover,a:link,a:visited&#123; text-decoration: underline;&#125;input,button&#123; border: none; outline: none;&#125;textarea&#123; outline: none;&#125;li,ol&#123; list-style: none;&#125;i &#123; font-style: normal;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;/* 多行文本域的控制 */textarea&#123; resize: none; /*用户无法调整元素的尺寸*/ /*resize: vertical;*/ /*用户可调整元素的高度*/ /*resize: horizontal;*/ /*用户可调整元素的宽度*/&#125;/* 文字对齐方式 */.text_ce&#123; text-align: center&#125;.text_rt&#123; text-align: right&#125;.text_lf&#123; text-align: left&#125;/* 浮动 */.fl&#123; float: left;&#125;.fr&#123; float: right;&#125;/* 清除浮动 */.clearfix:after&#123; content: ''; display: block; height: 0; clear: both; visibility: hidden;&#125;/* 弹性盒子 */.flex &#123; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex;&#125;.flex_v&#123; -webkit-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column;&#125;.flex1&#123; -webkit-box-flex: 1; -webkit-flex: 1; -ms-flex: 1; flex: 1;&#125;.flex2&#123; -webkit-box-flex: 2; -webkit-flex: 2; -ms-flex: 2; flex: 2;&#125;.flex3&#123; -webkit-box-flex: 3; -webkit-flex: 3; -ms-flex: 3; flex: 3;&#125;.flex_hc&#123; -webkit-justify-content: center; justify-content: center;&#125;.flex_hm&#123; display: -webkit-box; display: -webkit-flex; display: flex; -webkit-box-align: center; -webkit-align-items: center; align-items: center;&#125;.flex_ld&#123; -webkit-justify-content: space-between; justify-content: space-between;&#125;.flex_k&#123; -webkit-justify-content: space-around; justify-content: space-around;&#125;/* 字体超出省略号 *//* 一行文字 */.text_ellipsis&#123; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; word-wrap: normal; word-wrap: break-word; word-break: break-all;&#125;/* 多行文字 谷歌才会出现的效果，为确保其他浏览器不出现样式问题，height:xxxpx */.moretext_ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; word-break: break-all; word-wrap: break-word;&#125; 欢迎补充]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Hexo]]></title>
    <url>%2F2017%2F11%2F23%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[迁移注意问题说明 1.执行clone命名 git clone -b hexo 路径 2.安装依赖 依次执行 npm install hexo(最好全局安装hexo，不然hexo环境变量不主动配置) npm install hexo-deployer-git (*切记不要执行hexo init) 迁移后注意事项 新建博客命：hexo new post “博客名” 完成后先提交代码 直接提交到hexo分支上，不用向master分支上推。 提交代码时不用提交package-lock.json文件。只提交写的文件就行，.json后缀的文件都不用提交 执行发布命令 hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
