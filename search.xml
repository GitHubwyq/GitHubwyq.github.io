<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[axios封装]]></title>
    <url>%2F2019%2F06%2F17%2Faxios%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[使用说明1、安装axios npm install axios 2、建文件夹 一般会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。 3、引入 ①在main.js中引入http.js,并全局挂载它123import axios from './request/http.js' //引入http.jsVue.prototype.$http = axios //全局挂载封装的http.js ②在需要请求接口的地方引入api.js（当然你也可以全局挂载api.js） 4、使用12345this.$http.get(api.接口名路径).then((data)=&gt;&#123;&#125;).catch((err) =&gt; &#123; &#125;) 下面是代码部分http.js代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// 在http.js中引入axiosimport axios from 'axios'; //引入axiosimport Qs from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// import store from '@/store/index'; // vuex的路径根据自己的路径去写// import &#123; Toast &#125; from 'vant'; // vant的toast提示框组件，大家可根据自己的ui组件更改。//环境的切换 有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀（通过xios.defaults.baseURL可以设置axios的默认请求地址）if (process.env.NODE_ENV == 'development') &#123; axios.defaults.baseURL = 'https://cnodejs.org';&#125;else if (process.env.NODE_ENV == 'debug') &#123; axios.defaults.baseURL = 'https://cnodejs.org';&#125;else if (process.env.NODE_ENV == 'production') &#123; axios.defaults.baseURL = 'https://cnodejs.org';&#125;//设置请求超时 （axios.defaults.timeout）axios.defaults.timeout=10000;//post请求时需要加上请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';//请求前的拦截// 先导入vuex,因为我们要使用到里面的状态对象//请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)// 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！//响应拦截axios.interceptors.response.use( response =&gt; &#123; if (response.status === 200) &#123; return Promise.resolve(response); &#125; else &#123; return Promise.reject(response); &#125; &#125;, // 服务器状态码不是200的情况 error =&gt; &#123; if (error.response.status) &#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast(&#123; message: '登录过期，请重新登录', duration: 1000, forbidClick: true &#125;); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; &#123; router.replace(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125;, 1000); break; // 404请求不存在 case 404: Toast(&#123; message: '网络请求不存在', duration: 1500, forbidClick: true &#125;); break; // 其他错误，直接抛出错误提示 default: Toast(&#123; message: error.response.data.message, duration: 1500, forbidClick: true &#125;); &#125; return Promise.reject(error.response); &#125; &#125;);//get方法封装/* * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数]*/export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt; &#123; reject(err.data) &#125;) &#125;);&#125;//post方法封装/* * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数]*/ export function post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, QS.stringify(params)) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt; &#123; reject(err.data) &#125;) &#125;);&#125;//导出axiosexport default axios api.js代码部分1234567const api = &#123; //例子 index:&#123; indexPage:'/api/v1/topics' //例子百度首页 &#125;&#125;export default api 当然你也可以移步到我的github上去看它的详细使用过程 传送门]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue打包后路径报错问题]]></title>
    <url>%2F2019%2F06%2F10%2Fvue%E6%89%93%E5%8C%85%E5%90%8E%E8%B7%AF%E5%BE%84%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue文件打包后的问题打包后，打开index.html文件报错（net::ERR_CONNECTION_REFUSED）如图 报错原因是index.html文件的资源引入路径有错误 解决方案 步骤①、打开config/index.js文件，将build-&gt;assetsPublicPath改为“./”，即可，就是前面加个点。代码如下12345678910build: &#123; // Template for index.html index: path.resolve(__dirname, "../dist/index.html"), //新增打包后配置文件 // Paths assetsRoot: path.resolve(__dirname, "../dist"), assetsSubDirectory: "static", assetsPublicPath: "./", 步骤②、找到 build-&gt;utils.js,在里面加入一句publicPath:’../../‘,123456789if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, publicPath:'../../', fallback: 'vue-style-loader' &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue知识点汇总]]></title>
    <url>%2F2019%2F05%2F24%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1、vue中key值的作用 key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。最常见的用例是结合 v-for:123&lt;ul&gt; &lt;li v-for="item in items" :key="item.id"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:完整地触发组件的生命周期钩子触发过渡123&lt;transition&gt; &lt;span :key="text"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时， 会随时被更新，因此会触发过渡。 2、vue中子组件调用父组件的方法 子组件调用父组件的方法可以使用this.$emit() 3、vue等单页面应用及其优缺点 优点1、具有桌面应用的即时性、网站的可移植性和可访问性2、用户体验好、快，内容的改变不需要重新加载整个页面3、基于上面一点，SPA相对对服务器压力小4、良好的前后端分离。SPA和RESTful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化5、同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端 缺点1、不利于SEO。（如果你看中SEO，那就不应该在页面上使用JavaScript，你应该使用网站而不是Web应用）2、初次加载耗时相对增多3、导航不可用，如果一定要导航需要自行实现前进、后退 4、v-show和v-if指令的共同点和不同点? v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏（不操作DOM元素） v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果（注意：v-if 可以实现组件的重新渲染） 5、如何让CSS只在当前组件中起作用? 将当前组件的&lt;style&gt;修改为&lt;style scoped&gt;&lt;/style&gt; 6、深度选择器/deep/(&gt;&gt;&gt;) 以Element-ui为例。那就是在父组件写css时，样式选择器中加上 /deep/或者 &gt;&gt;&gt; 这两个标记，即可渗透到子组件的样式中加上/deep/或者&gt;&gt;&gt;后123456789.back_index /deep/.el-menu-item&#123; color:#a7b1c2!important;&#125;或者.back_index &gt;&gt;&gt; .el-menu-item&#123; color:#a7b1c2!important;&#125; 子组件的样式就被父组件的样式给修改了 7、的作用是什么? &lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。 8、指令v-el和v-ref的作用是什么? v-el 为DOM元素注册一个索引，通过v-el我们可以获取到DOM对象1&lt;span v-el:msg&gt;hello&lt;/span&gt; this.$els.msg /hello v-ref 通过v-ref获取到整个组件（component）的对象。访问：this.$refs.v-ref后的值 9、Vuex的原理和使用方法 数据单向流动 一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动。但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的。Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心。 Vuex的组成：一个实例化的Vuex.Store由state, mutations（更改信息是同步更改）和actions（更改信息是异步更改）三个属性组成: 1、state中保存着共有数据2、改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的3、如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改. 10、vue中Computed 和 Watch的使用和区别 computed: 可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会出发这个属性。具有缓存能力，所以只有当数据再次改变时才会重新渲染，否则就会直接拿取缓存中的数据。（有缓存） Watch：当你需要在数据变化响应时，执行异步操作，或高性能消耗的操作，自定义 watcher 的方式就会很有帮助 vue官网的例子:如下12345&lt;div id="myDiv"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;input type="text" v-model="fullName"&gt;&lt;/div&gt; computed方式12345678910111213new Vue(&#123; el:"#myDiv", data:&#123; firstName:"Den", lastName:"wang", &#125;, computed:&#123; fullName:function()&#123; return this.firstName + " " +this.lastName; &#125; &#125;&#125;) watch方式12345678910111213141516new Vue(&#123; el: '#myDiv', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 11、active-class是哪个组件的属性？ active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换 使用方法1、直接在路由js文件中配置linkActiveClass123export default new Router(&#123; linkActiveClass: 'active',&#125;) 2、在router-link中写入active-class1router-link to="/home" class="menu-home" active-class="active"&gt;首页&lt;/router-link&gt; 12、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ 在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 例如 : this.$route.params.id 13、vue-router有哪几种导航钩子？1.全局钩子 主要包括beforeEach和aftrEach, beforeEach函数有三个参数： 1、to: router即将进入的路由对象2、from: router当前导航即将离开的路由3、next: Function继续执行函数 next()：继续执行 next(false)：中断当前的导航。 next(‘/‘) 或 next({ path: ‘/‘ })：跳转新页面，常用于登陆失效跳转登陆 afterEach函数不用传next()函数 这类钩子主要作用于全局,一般用来判断权限,以及以及页面丢失时候需要执行的操作,例如:1234567891011121314151617181920//使用钩子函数对路由进行权限跳转router.beforeEach((to, from, next) =&gt; &#123; const role = localStorage.getItem('ms_username'); if(!role &amp;&amp; to.path !== '/login')&#123; next('/login'); &#125;else if(to.meta.permission)&#123; // 如果是管理员权限则可进入，这里只是简单的模拟管理员权限而已 role === 'admin' ? next() : next('/403'); &#125;else&#123; // 简单的判断IE10及以下不进入富文本编辑器，该组件不兼容 if(navigator.userAgent.indexOf('MSIE') &gt; -1 &amp;&amp; to.path === '/editor')&#123; Vue.prototype.$alert('vue-quill-editor组件不兼容IE10及以下浏览器，请使用更高版本的浏 览器查看', '浏览器不兼容通知', &#123; confirmButtonText: '确定' &#125;); &#125;else&#123; next(); &#125; &#125;&#125;) 2、路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫：1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 3、组件内的守卫 最后，你可以在路由组件内直接定义以下*路由导航守卫： beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。12345beforeRouteUpdate (to, from, next) &#123; // just use `this` this.name = to.params.name next()&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消12345678beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; next() &#125; else &#123; next(false) &#125;&#125; 14、router路由跳转时，传参方式params query区别 1、传参可以使用params和query两种方式2、使用params传参只能用name来引入路由，即push里面只能是name:’xxxx’,不能是path:’/xxx’,因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined3、使用query传参使用path来引入路由4、params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系5、二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示 15、Vue的双向数据绑定原理是什么？ vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 16、如何封装 vue 组件 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次笔试面试题]]></title>
    <url>%2F2019%2F05%2F18%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记一次笔试面试题经历刚拿到题目的时候是有点懵逼的。问了一下面试官，确定了一下需求。开始着手 附上笔试题链接（http://face.gokxd.cn/） 题目大体需求：两张照片合成一张，只替换照片的人脸部分明确步骤: ①、给出的页面有点不简洁明了，自己动手重新设计布局②、确定开放api接口（推荐使用face++，传送门）③、上传照片时需要判断是否是人物照片（调用接口地址，传送门） 附上部分代码部分识别人脸部分代码1234567891011121314151617181920212223$.ajax(&#123; url: url, type: 'POST', data: data, cache: false, success(data) &#123; console.log(data.faces.length) //data.faces 被检测出的人脸数组，具体包含内容见下文。注：如果没有检测出人脸则为空数组 if(data.faces.length != 0)&#123; document.getElementById('show').src=base1; &#125;else if(data.faces.length == 0)&#123; $.alert(&#123; title: '', text: '未检测到人脸,请重新选择图片！', onOK: function () &#123; //点击确认 &#125; &#125;); &#125; &#125;, &#125;) 人脸融合部分代码123456789101112131415161718192021222324252627var postData = &#123; api_key:'你注册的api_key', api_secret:'你注册的api_secret', template_base64:mouldPhoSrc, // template_rectangle:'70,80,100,100', merge_base64:fusePhoSrc&#125;$.ajax(&#123; dataType: 'json', type: 'POST' , url: 'https://api-cn.faceplusplus.com/imagepp/v1/mergeface', data: postData, success: function(response)&#123; if(typeof(response.error_message) == "undefined")&#123; // todo: 在这里添加生成后的逻辑，response.result 为生成图的base64编码 $('.uploadpic').attr('src', 'data:image/jpg/png;base64,' + response.result); &#125;else&#123; // todo: 在这里添加上传失败的逻辑 alert('请重新上传照片23'); &#125; &#125;, error: function(xhr, status, error)&#123; console.log(xhr.responseText); // todo: 在这里添加上传失败的逻辑 alert('请重新上传照片'); &#125;&#125;); 附上完整项目链接，由于没做屏幕适配，所以移动端画面有点乱，后续进行优化。 人脸融合传送门]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序和vue有哪些不同？]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Cvue%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1.生命周期小程序 onLoad：页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow：页面显示 每次打开页面都会调用一次 onReady：页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。12345wx.setNavigationBarTitle(&#123;title:this.data.titleName&#125;); onHide：页面隐藏 当 navigateTo或底部tab切换时调用。 onUnload：页面卸载 当 redirectTo或 navigateBack的时候调用。 Vue.js 创建前/后：(这两个生命周期里获取不到dom元素) 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后：（mounted生命周期里可以获取到dom元素） 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后： 当data变化时，会触发beforeUpdate和updated方法。 销毁前/后： 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 2、数据双向绑定1、设置值 在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。12345678910&lt;div id="app"&gt; &lt;input v-model="reason" placeholder="填写理由" class='reason'/&gt;&lt;/div&gt; new Vue(&#123; el: '#app', data: &#123; reason:'' &#125;&#125;) 然而在小程序中，却没有这个功能。 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。 下面是代码123456789101112&lt;input bindinput="bindReason" placeholder="填写理由" class='reason' value='&#123;&#123;reason&#125;&#125;' name="reason" /&gt; Page(&#123; data:&#123; reason:'' &#125;, bindReason(e) &#123; this.setData(&#123; reason: e.detail.value &#125;) &#125;&#125;) 2、取值 vue中，通过 this.reason取值。 小程序中，通过 this.data.reason取值。 3.组件通信1、子组件的使用 在vue中，需要： 1、编写子组件2、在需要使用的父组件中通过 import引入3、在 vue的 components中注册4、在模板中使用123456789101112131415161718192021222324252627282930313233343536373839404142434445//子组件 bar.vue&lt;template&gt; &lt;div class="search-box"&gt; &lt;div @click="say" :title="title" class="icon-dismiss"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:&#123; title:&#123; type:String, default:'' &#125; &#125; &#125;, methods:&#123; say()&#123; console.log('明天不上班'); this.$emit('helloWorld') &#125; &#125; &lt;/script&gt; // 父组件 foo.vue&lt;template&gt; &lt;div class="container"&gt; &lt;bar :title="title" @helloWorld="helloWorld"&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import Bar from './bar.vue'export default&#123;data:&#123; title:"我是标题"&#125;,methods:&#123; helloWorld()&#123; console.log('我接收到子组件传递的事件了') &#125;&#125;,components:&#123; Bar&#125;&lt;/script&gt; 子组件和父组件通信可以通过 this.$emit将方法和数据传递给父组件。 小程序中 1、编写子组件2、在子组件的 json文件中，将该文件声明为组件123&#123; "component": true&#125; 3、在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径123"usingComponents": &#123; "tab-bar": "../../components/tabBar/tabBar" &#125; 4、在父组件中，直接引入即可1&lt;tab-bar currentpage="index"&gt;&lt;/tab-bar&gt; 完整代码如下123456789101112// 子组件&lt;!--components/tabBar/tabBar.wxml--&gt;&lt;view class='tabbar-wrapper'&gt; &lt;view class='left-bar &#123;&#123;currentpage==="index"?"active":""&#125;&#125;' bindtap='jumpToIndex'&gt; &lt;text class='iconfont icon-shouye'&gt;&lt;/text&gt; &lt;view&gt;首页&lt;/view&gt; &lt;/view&gt; &lt;view class='right-bar &#123;&#123;currentpage==="setting"?"active":""&#125;&#125;' bindtap='jumpToSetting'&gt; &lt;text class='iconfont icon-shezhi'&gt;&lt;/text&gt; &lt;view&gt;设置&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 4、父子组件通信 在vue中父组件向子组件传递数据，只需要在子组件通过 v-bind传入一个值，在子组件中，通过 props接收，即可完成数据的传递，示例：123456789101112131415161718192021222324252627282930313233// 父组件 foo.vue&lt;template&gt; &lt;div class="container"&gt; &lt;bar :title="title"&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from './bar.vue'export default&#123;data:&#123; title:"我是标题"&#125;,components:&#123; Bar&#125;&lt;/script&gt; // 子组件bar.vue&lt;template&gt; &lt;div class="search-box"&gt; &lt;div :title="title" &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:'' &#125; &#125;&#125;&lt;/script&gt; 小程序中 父组件向子组件通信和vue类似，但是小程序没有通过 v-bind，而是直接将值赋值给一个变量，如下：1&lt;tab-bar currentpage="index"&gt;&lt;/tab-bar&gt; 此处， “index”就是要向子组件传递的值,在子组件 properties中，接收传递的值。12345678properties: &#123; // 弹窗标题 currentpage: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: 'index' // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125;&#125; 子组件向父组件通信和 vue也很类似，代码如下：1234567891011121314151617//子组件中methods: &#123; // 传递给父组件 cancelBut: function (e) &#123; var that = this; var myEventDetail = &#123; pickerShow: false, type: 'cancel' &#125; // detail对象，提供给事件监听函数 this.triggerEvent('myevent', myEventDetail) //myevent自定义名称事件，父组件中使用 &#125;,&#125; //父组件中&lt;bar bind:myevent="toggleToast"&gt;&lt;/bar&gt; // 获取子组件信息toggleToast(e)&#123; console.log(e.detail)&#125; 如果父组件想要调用子组件的方法vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：12345//子组件&lt;bar ref="bar"&gt;&lt;/bar&gt; //父组件this.$refs.bar.子组件的方法 小程序是给子组件添加 id或者 class，然后通过 this.selectComponent找到子组件，然后再调用子组件的方法,示例：12345//子组件&lt;bar id="bar"&gt;&lt;/bar&gt; // 父组件this.selectComponent('#bar').子组件的方法 5、条件渲染 vue:使用v-if指令，v-else表示v-if的else块，v-else-if表示v-if 的“else-if 块”123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 微信小程序：使用wx:if,wx:else表示wx:if的else块，wx:elif表示wx:if的”else-if”块123&lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; 1 &lt;/view&gt;&lt;view wx:elif="&#123;&#123;length &gt; 2&#125;&#125;"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 6、显示隐藏元素 VUE1v-show="..." 微信小程序：1hidden="&#123;&#123;...&#125;&#125;" 7、绑定classVue 全用v-bind，或者简写为:bind,和本有的class分开写1&lt;div class="test" v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 小程序1&lt;view class="test &#123;&#123;isActive ? 'active':'' &#125;&#125;"&gt;&lt;/view&gt; 8、事件处理Vue 使用v-on:event绑定事件，或者使用@event绑定事件(v-on可以简写为@)123456&lt;button v-on:click="counter += 1"&gt; Add 1&lt;/button&gt;&lt;button v-on:click.stop="counter+=1"&gt; Add1&lt;/button&gt; //阻止事件冒泡 微信小程序 全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件123456&lt;button bindtap="clickMe"&gt; 点击我&lt;/button&gt;&lt;button catchtap="clickMe"&gt; 点击我&lt;/button&gt; //阻止事件冒泡 9、绑定事件传参Vue vue绑定事件的函数传参数时，可以把参数写在函数后面的括号里1&lt;div @click="changeTab(1)"&gt;哈哈&lt;/div&gt; 微信小程序 微信小程序的事件我试过只能传函数名，至于函数值，可以绑定到元素中，在函数中获取1&lt;view data-tab="1" catchtap="changeTab"&gt;哈哈&lt;/view&gt; 123changeTab(e)&#123; var _tab = e.currentTarget.dataset.tab; &#125; 暂时总结这么多]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动吸顶效果的实现方式]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[实现方式1.使用 position:sticky 实现 2.使用 JQuery 的 offset().top 实现 3.使用原生的 offsetTop 实现 一、使用 position:sticky 实现 1.什么是sticky（粘性定位） 粘性定位 sticky 相当于相对定位 relative 和固定定位 fixed 的结合；在页面元素滚动过程中，某个元素距离其父元素的距离达到 sticky 粘性定位的要求时；元素的相对定位 relative 效果变成固定定位 fixed 的效果。 2.如何使用？ 使用条件 1.父元素不能 overflow:hidden 或者 overflow:auto 属性;2.必须指定 top、bottom、left、right 4 个值之一，否则只会处于相对定位3.父元素的高度不能低于 sticky 元素的高度4.sticky 元素仅在其父元素内生效 在需要滚动吸顶的元素加上以下样式便可以实现这个效果：12345.sticky &#123; position: -webkit-sticky; position: sticky; top: 0;&#125; 二、使用 JQuery 的 offset().top 实现我们知道 JQuery 中封装了操作 DOM 和读取 DOM 计算属性的 API，基于 offset().top 这个 API 和 scrollTop() 的结合，我们也可以实现滚动吸顶效果。 12345678 window.addEventListener('scroll', self.handleScrollOne);...handleScrollOne: function() &#123; let self = this; let scrollTop = $('html').scrollTop(); let offsetTop = $('.title_box').offset().top; self.titleFixed = scrollTop &gt; offsetTop;&#125; 三、使用原生的 offsetTop 实现我们知道 offsetTop 是相对定位父级的偏移量，倘若需要滚动吸顶的元素出现定位父级元素，那么 offsetTop 获取的就不是元素距离页面顶部的距离。我们可以自己对 offsetTop 做以下处理： 12345678910111213141516171819202122232425 getOffset: function(obj,direction)&#123; let offsetL = 0; let offsetT = 0; while( obj!== window.document.body &amp;&amp; obj !== null )&#123; offsetL += obj.offsetLeft; offsetT += obj.offsetTop; obj = obj.offsetParent; &#125; if(direction === 'left')&#123; return offsetL; &#125;else &#123; return offsetT; &#125;&#125; ``` ##### 使用 ```jswindow.addEventListener('scroll', self.handleScrollTwo);...handleScrollTwo: function() &#123; let self = this; let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; let offsetTop = self.getOffset(self.$refs.pride_tab_fixed); self.titleFixed = scrollTop &gt; offsetTop;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[琐碎小问题！]]></title>
    <url>%2F2018%2F02%2F04%2F%E7%90%90%E7%A2%8E%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、去除select的默认三角样式12345select&#123; -webkit-appearance: none; -webkit-tap-highlight-color: #fff; outline: 0;&#125; 2、文字超出隐藏12345div&#123; overflow: hidden; white-space: nowrap; //不换行 text-overflow: ellipsis; //超出省略号&#125; 3、iframe通过下列代码可以实现去除边框，滚动条，但是需要调整好高度，而且对应的子页面，高度应该是固定的，才容易使用 1&lt;iframe src="http://www.zhixin001.com/test/about.html" style="width:100%;height:1100px" name="iframe_a" frameborder="no" border="0" marginwidth="0" marginheight="0" scrolling="no" allowtransparency="yes"&gt;&lt;/iframe&gt; 4、如何控制窗体滚动高度的问题？如果只是为了获取当前网页的窗体的滚动高度，直接使用window.pageYOFFset就可以了（IE9+），桌面和移动端都支持但是window.pageYOFFset是一个只读属性，我们无法用来设置窗体的滚动高度，此时，就要找到对应的滚动元素，通过设置scrollTop值来改变窗体的滚动位置然而，桌面和移动端的窗体滚动元素是不一样的12document.documentElement.scrollTop;（只在PC端生效）document.body.scrollTop;（只在移动端生效） 使用document.scrollingElement.scrollTop来控制如：1document.scrollingElement.scrollTop = 400 5、超出部分隐藏123overflow:hidden;text-overflow:ellipsis;white-space:nowrap 6、查看本机ip地址 命令行输入 ipconfig 7、input框只能输入整数12onkeyup="value=value.replace(/[^0-9]/g,'')" (包括0)onkeyup="value=value.replace(/^(0+)|[^\d]+/g,'')" （不包括0） 8、input框限制输入长度 （可以在type为number时 maxlength无效时使用）1oninput="if(value.length&gt;5)value=value.slice(0,5)" 9、H5和原生交互12345678910111213141516171819202122var u = navigator.userAgent, app = navigator.appVersion;var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; //gvar isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端function showToast(data)&#123; if(getCookie("VERSION")||getCookie("PHONETYPE")||getCookie("DEVICEID"))&#123; if(isIOS) &#123; window.webkit.messageHandlers.showToast.postMessage(data); &#125; else if(isAndroid) &#123; window.android.showToast(JSON.stringify(data)); &#125; &#125;else&#123; if(data.type==1)&#123; $.showLoading(" "); &#125;else if(data.type==2)&#123; $.hideLoading(); &#125;else if(data.type==3)&#123; $.toast(data.title, "text"); &#125; &#125;&#125; 10、修改单选框和复选框的样式123&lt;!-- html --&gt;&lt;input type="checkbox" id="check" name="check" /&gt;&lt;label for="check"&gt;Checkbox&lt;/label&gt; 12345678910111213141516input[type=checkbox] &#123;display: none;&#125;input[type=checkbox] + label:before &#123; content: ""; border: 1px solid #000; font-size: 11px; line-height: 10px; margin: 0 5px 0 0; height: 10px; width: 10px; text-align: center; vertical-align: middle;&#125;input[type=checkbox]:checked + label:before &#123; content: "\2713";&#125; 11、动画卡顿时，开启硬件加速123选择器&#123; transform: translateZ(0);&#125; 12、Color + Border = Border-Color1234input[type="text"] &#123; color: red; border: 1px solid;&#125; 13、高德的事件绑定123$(document).on('click','类名',function()&#123;&#125;) 14、禁止移动端背景层滚动 弹出时设置12document.body.style.overflow = 'hidden';document.documentElement.style.overflow = 'hidden' 关闭弹出层时设置 把值设置成auto即可 15、ios的回弹效果123$('').on('touchmove',function()&#123; event.preventDefault();&#125;) 16、box-shadow1box-shadow: 10px 10px 5px #88888 第一个值：水平阴影的偏移量，为正值时生成右边阴影，为负时，生成左边阴影第二个值：垂直阴影的偏移量，为正值时生成底部阴影，为负值时，生成顶部阴影第三个值：阴影模糊值第四个值：阴影颜色]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三角形原理！]]></title>
    <url>%2F2017%2F12%2F10%2Fcss%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E5%8E%9F%E7%90%86-1%2F</url>
    <content type="text"><![CDATA[对于一个块级元素，但我们分别将元素的上下左右四个border设置成一个比较大的像素（如10px），样式设置成solid ,分别设置成不同的颜色的时候，同时将元素的width,height设置为0.这时我们将会看到四条边均呈现为三角形的形状。如图： 其css样式为： 12345678.element&#123; width: 0px; height: 0px; border-top: 20px solid aqua; border-right: 20px solid #760000; border-bottom: 20px solid blue; border-left: 20px solid darkkhaki;&#125; 一个普通的div。四个三角形分别是四条border四条border所呈现出来的，而我们最终的效果好像跟一个三角形的关系比较大些。如果得到一个三角形呢？其实这个很简单，我们只需要把其余三条border颜色属性设置为transparent（透明）的样式，另一个border的颜色属性保持不变。 看代码html部分123&lt;div class="element"&gt; &lt;/div&gt; css部分12345678.element&#123; width: 0px; height: 0px; border-top: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 20px solid darkkhaki;&#125; 此时的效果：如下图 好了，三角形出来了。那我们也就实现了最为关键的的地方。我们在弄出来一个白色的三角形，然后将白色三角形覆盖到这个有色三角形之上，但是不能完全覆盖，让其露出一个尖角的效果来。这就是基本的原理。 2.实现 首先需要一个div容器，设置border,width,height的属性，同时将设置其为相对定位。 上代码html部分123&lt;div class="angle-wrapper"&gt; &lt;/div&gt; css部分1234567.angle-wrapper &#123; width: 300px; height: 200px; position: relative; margin: 20px auto; border: 2px solid #cccccc;&#125; 效果图如下： 然后需要为这个在这个div右边框上添加两个三角形，一个三角形颜色与边框颜色相同，另一个三角形颜为白色，用于覆盖第一个三角形颜色的一部分。 这里我们使用元素的伪选择器:before,:after来加入这两个三角形，before和after默认为行内元素，所以首先要将其设置为块级元素，绝对定位。 首先添加before伪选择器，用它来生成与border颜色的相同的第一个三角形，并将其定位到左边框上。 上代码1234567891011.angle-wrapper:before &#123; content: ''; width: 0; height: 0; border: 20px solid transparent; border-left-color: #cccccc; position: absolute; left: 100%; top: 50%; margin-top: -20px;&#125; 效果图如下： 然后添加after伪选择器，用它生成一个白色的三角形，并将其定位到左边框上。这里需要注意的是白色三角形的大小要比有色三角形要小一些，小多少要根据div边框的大小而定。我这里边框为2px,所以白色三角形就比灰色三角形就小两个px。这样可以避免白色三角形将灰色三角形全覆盖，然后可以产生尖角的效果来。（我这里说的大小就是设置三角形时的border的px值，如after这里是18px,before那里是20px） 上代码：1234567891011.angle-wrapper:after &#123; content: ""; width: 0; height: 0; border: 18px solid transparent; border-left-color: #FFFFFF; position: absolute; left: 100%; top: 50%; margin-top: -18px;&#125; 效果图如下： 完成。（这个对话框做的有点丑哈）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS reset文件]]></title>
    <url>%2F2017%2F11%2F30%2Fcss-reset%2F</url>
    <content type="text"><![CDATA[css reset文件 为了复用一些css属性，最近花了点时间把一些常用的总结一下不多说，上代码 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131*&#123; margin: 0; padding: 0;&#125;html&#123; overflow-y: scroll; &#125;a&#123; text-decoration: none;&#125;a:active,a:hover,a:link,a:visited&#123; text-decoration: underline;&#125;input,button&#123; border: none; outline: none;&#125;textarea&#123; outline: none;&#125;li,ol&#123; list-style: none;&#125;i &#123; font-style: normal;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;/* 多行文本域的控制 */textarea&#123; resize: none; /*用户无法调整元素的尺寸*/ /*resize: vertical;*/ /*用户可调整元素的高度*/ /*resize: horizontal;*/ /*用户可调整元素的宽度*/&#125;/* 文字对齐方式 */.text_ce&#123; text-align: center&#125;.text_rt&#123; text-align: right&#125;.text_lf&#123; text-align: left&#125;/* 浮动 */.fl&#123; float: left;&#125;.fr&#123; float: right;&#125;/* 清除浮动 */.clearfix:after&#123; content: ''; display: block; height: 0; clear: both; visibility: hidden;&#125;/* 弹性盒子 */.flex &#123; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex;&#125;.flex_v&#123; -webkit-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column;&#125;.flex1&#123; -webkit-box-flex: 1; -webkit-flex: 1; -ms-flex: 1; flex: 1;&#125;.flex2&#123; -webkit-box-flex: 2; -webkit-flex: 2; -ms-flex: 2; flex: 2;&#125;.flex3&#123; -webkit-box-flex: 3; -webkit-flex: 3; -ms-flex: 3; flex: 3;&#125;.flex_hc&#123; -webkit-justify-content: center; justify-content: center;&#125;.flex_hm&#123; display: -webkit-box; display: -webkit-flex; display: flex; -webkit-box-align: center; -webkit-align-items: center; align-items: center;&#125;.flex_ld&#123; -webkit-justify-content: space-between; justify-content: space-between;&#125;.flex_k&#123; -webkit-justify-content: space-around; justify-content: space-around;&#125;/* 字体超出省略号 *//* 一行文字 */.text_ellipsis&#123; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; word-wrap: normal; word-wrap: break-word; word-break: break-all;&#125;/* 多行文字 谷歌才会出现的效果，为确保其他浏览器不出现样式问题，height:xxxpx */.moretext_ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; word-break: break-all; word-wrap: break-word;&#125; 欢迎补充]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Hexo]]></title>
    <url>%2F2017%2F11%2F23%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[迁移注意问题说明 1.执行clone命名 git clone -b hexo 路径 2.安装依赖 依次执行 npm install hexo(最好全局安装hexo，不然hexo环境变量不主动配置) npm install hexo-deployer-git (*切记不要执行hexo init) 迁移后注意事项 新建博客命：hexo new post “博客名” 完成后先提交代码 直接提交到hexo分支上，不用向master分支上推。 提交代码时不用提交package-lock.json文件。只提交写的文件就行，.json后缀的文件都不用提交 执行发布命令 hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
